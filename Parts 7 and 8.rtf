{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red27\green31\blue34;\red255\green255\blue255;}
\margl1440\margr1440\vieww12860\viewh11760\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Hannah Beilinson Lab 7E\
Parts 7 and 8\
\
Part 7:\
\pard\pardeftab720\sl360\partightenfactor0
\cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Describe what's happening in the screenshot and write up something you found useful about the JavaScript debugger.\
\
In the screenshot, my code is at the point of having taken in the input (\'931 2 nip .s\'94), and having processed 1 and 2. It is now entering the loop in runRepl for the third time. It is about to run process on nip, after having pushed 1 and 2. (At the exact moment of the screenshot, it is incrementing i by 1 to continue the loop).\
\
I found the ability to simultaneously follow the exact location in the code, follow the values of all the variables, and see the results in the web browser to be incredibly useful. It allowed me to see exactly how the list was being iterated through, so that when there was a bug I could see where it was happening. Since simply viewing the web page doesn\'92t allow me to see any form of error message, my program would sometimes get stuck in an infinite loop, and without the debugger it would have been impossible to tell which loop it was and why it was happening.\
\
Part 8:\
What new perspective did you gain by redoing the lab in Javascript?\
\
By redoing the lab in Javascript I was able to see the ways in which strict type-checking can actually hold back programming. Sometimes this was difficult to see in Racket, since I often found Racket\'92s lack of types to compound its already visually-disorienting nature. However, with Javascript, not having to strictly declare the type of every variable allowed me to have more flexibility between user-defined and programmer-defined functions. I still chose to have two different arrays, as I did in C++, but I was able to implement them in a more similar way since I didn\'92t have to worry as much about the type of each part.\
\
\
Can you point to one instance where the lack of types in JavaScript was damaging to your productivity?\
\
Probably the most obvious difference between Javascript and C++ when it comes to types in a relatively simple program is the difference between number types. In C++ it was very easy to follow the FORTH standard of using only integers, by simply declaring that all inputs into stacks must be integers. In Javascript, this would be more difficult. I ultimately decided to allow all numbers, because it seemed like I might as well conform to the natural flexibility of Javascript, but this feature does make it less FORTH compliant.\
\
\
\pard\pardeftab720\sl360\partightenfactor0
\cf2 Did JavaScript's lack of types surprise you? Or hurt you in any way? Or was it easier than C++ because you didn't have to annotate the program with types? Either answer is fine here, as long as you provide some thoughtful reflection.\
\cb1 \uc0\u8232 Javascript\'92s lack of types did surprise me. I generally associate loose typing mostly with Python and more static typing with languages that are more closely related to C and Java. Thus, I thought Javascript would at least have more typing than it does. Overall, however, I think it helped me to not have to annotate types. Especially when it comes to creating a map of functions that take and return stacks, C++ could type-annotation could get tedious. Since this amount of code was small enough for it to be relatively manageable to keep track of types myself, it was kind of a relief to not have to type annotate (especially since I come from a Python background). However, if I were doing a more in-depth project, or if I were doing a project for which I hadn\'92t already put a lot of thought into the types, I imagine the lack of type declaration could begin to get dangerous. In this particular project, it was easy not to have types since I already had to think through all the types when I did the same project in C++.\
\
\
\pard\pardeftab720\sl360\sa320\partightenfactor0
\cf2 \cb3 Describe a few features of programming your previous lab that you used here. For example, describe how you observed any of the following in JS:\
The feature of JS I probably found most interesting in comparison to C++ was the implementation of maps (or dictionaries, as I learned about them in Python). I always thought of maps and lists (or arrays) as very separate types of data-organization. However, in JS they\'92re essentially equivalent, with the only difference being whether the keys are indices or strings. I thought this was really interesting because it made the coding both more fluid and at times more confusing. It also helped with converting a certain feature of my lab from C++ to JS. In C++ to check if a word was a key in one of the function maps I would have to try to access it, and then see if it returned anything. Since JS implements maps as a kind of array, it\'92s possible to simply use the \'93in\'94 function to check if the keyword is in the map. \
I also liked the ease of mutating objects in Javascript. Whereas in C++ this lab was done by returning a new stack each time a function was performed, in Javascript the single stack object could be easily mutated. This is more efficient, and also allows for the type of graphical representation created by renderStack(). The same mutations could be done in C++, but it would require passing around pointers. In Javascript, this process is far more streamlined, allowing everything to be a procedure, rather than a function.\
\
}